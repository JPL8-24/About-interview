#前端面试
###html全局属性
* accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素
* class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素
* contenteditable: 指定元素内容是否可编辑
* contextmenu: 自定义鼠标右键弹出菜单内容
* data-*: 为元素增加自定义属性
* dir: 设置元素文本方向
* draggable: 设置元素是否可拖拽
* dropzone: 设置元素拖放类型： copy, move, link
* hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
* id: 元素id，文档内唯一
* lang: 元素内容的的语言
* spellcheck: 是否启动拼写和语法检查
* style: 行内css样式
* tabindex: 设置元素可以获得焦点，通过tab可以导航
* title: 元素相关的建议信息
* translate: 元素和子孙节点内容是否需要本地化

###http methods

* 一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可
* GET是最常用的方法，通常用于请求服务器发送某个资源。
* HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分
* PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它
* POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。
* TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。
* OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。
* DELETE请求服务器删除请求URL指定的资源

###HTTP 请求报文

* 1.首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF
* 2.首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束
* 3.请求头和消息实体之间有一个CRLF分隔
* 4.根据实际请求需要可能包含一个消息实体 一个请求报文例子如下：

```
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&age=25
```

###http 响应报文
1. 首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF
2. 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部
3. 响应头部和响应实体之间用一个CRLF空行分隔
4. 最后是一个可能的消息实体 响应报文例子如下：

```
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1

{"name": "qiu", "age": 25}
```

###HTTP缓存
####分为强缓存和协商缓存
1. 实现强缓存通过`Expires`和`cache-control`。强缓存表示在缓存期间不需要请求。
`Expires: Wed, 22 Oct 2018 08:41:00 GMT`

Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

```
Cache-control: max-age=30
```
Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求
简单的例子

```
  浏览器发访问http://localhost:10080/
  -       '请求报文没带 Cache-Control' 客户端说我要访问首页
  
  服务器返回数据
  -       '响应报文带:Cache-Control : max-age = 604800'  服务器说给你index.html和加载里面资源,并告诉你这些资源一周之内不要不必确认了
  
  浏览器刷新的网页再次访问http://localhost:10080/时
  -        里面的资源就不会再发送请求了,直接从缓存中拿  你会在chrome,network中看到Time是0(from memory catch)

  服务器返回数据
  -       服务器只返回index.html文件


  这时候你强制刷新浏览器(command+shift+R) 
  -       '请求报文带 Catche Contrl：no-cache '客户端说我不要缓存过的数据，我要源服务器的数据
  
 服务器返回数据
  -       服务器返回index.html文件和依赖的资源
```
###协商缓存
第一种：If-Modified-Since／Last-Modified
服务器会下发一个Last-Modified最后修改时间。然后浏览器会记住这个时间。当浏览器第二次请求时会带上if-modified-since的时间。服务器可以去比较这份文件在if-modified-since的时间后是否修改过。如果没有修改过，那就返回304.

* Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
* If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If- -Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified- Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说 明资源又被改动过，则响应整片资源内容(写在响应消息包体内)，HTTP 200;若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包 体，节省浏览)，告知浏览器继续使用所保存的cache。

上面那个代码中我们服务器并没有实现去记录文件修改时间，我们只要拿一段时间内去比较。我们知道了使用
if-modified-since，服务器就要每次记录文件的一个修改时间。所以用时间去判断并不是很好。
第二种：Etag/ If-None-Match
服务器Etag会下发一个字符串，然后浏览器在第二次请求时会在if-none-match中带上这个字符串。这时候服务器可以比较两个字符串，如果相同，就让浏览器去缓存中去取。

* Etag:web服务器响应请求时，告诉浏览器当前资源在服务器
的唯一标识(生成规则由服务器决定)
* If-None-Match:当资源过期时(使用Cache-Control标识的max- age)，发现资源具有Etage声明，则再次向web服务器请求时带 上头If-None-Match (Etag的值)。web服务器收到请求后发现 有头If-None-Match 则与被请求资源的相应校验串进行比对，决 定返回200或304

##UDP协议
###面向报文
UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作

* 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
* 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作、

###不可靠性
1. 无连接
2. 协议收到什么数据就传递什么数据，不会备份数据
3. 没有佣塞控制，以恒定的速度发送数据

###高效
udp头部8个字节，tcp20个字节

###传输方式

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

##TCP协议

<img src='https://raw.githubusercontent.com/externalFa/About-interview/master/img/屏幕快照%202018-07-28%20上午10.51.55.png'>
为什么连接建立需要三次握手，而不是两次握手？

防止失效的连接请求报文段被服务端接收，从而产生错误。

PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。
若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。







