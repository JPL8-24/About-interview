
## html全局属性
* accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素
* class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素
* contenteditable: 指定元素内容是否可编辑
* contextmenu: 自定义鼠标右键弹出菜单内容
* data-*: 为元素增加自定义属性
* dir: 设置元素文本方向
* draggable: 设置元素是否可拖拽
* dropzone: 设置元素拖放类型： copy, move, link
* hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
* id: 元素id，文档内唯一
* lang: 元素内容的的语言
* spellcheck: 是否启动拼写和语法检查
* style: 行内css样式
* tabindex: 设置元素可以获得焦点，通过tab可以导航
* title: 元素相关的建议信息
* translate: 元素和子孙节点内容是否需要本地化

## http methods

* 一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可
* GET是最常用的方法，通常用于请求服务器发送某个资源。
* HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分
* PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它
* POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。
* TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。
* OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。
* DELETE请求服务器删除请求URL指定的资源

## HTTP 请求报文

* 1.首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF
* 2.首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束
* 3.请求头和消息实体之间有一个CRLF分隔
* 4.根据实际请求需要可能包含一个消息实体 一个请求报文例子如下：

```
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&age=25
```

## http 响应报文
1. 首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF
2. 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部
3. 响应头部和响应实体之间用一个CRLF空行分隔
4. 最后是一个可能的消息实体 响应报文例子如下：

```
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1

{"name": "qiu", "age": 25}
```

## HTTP缓存
#### 分为强缓存和协商缓存
强缓存 强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。

协商缓存 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。

1. 实现强缓存通过`Expires`和`cache-control`。强缓存表示在缓存期间不需要请求。
`Expires: Wed, 22 Oct 2018 08:41:00 GMT`

Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

```
Cache-control: max-age=30
```
Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求
简单的例子

```
  浏览器发访问http://localhost:10080/
  -       '请求报文没带 Cache-Control' 客户端说我要访问首页
  
  服务器返回数据
  -       '响应报文带:Cache-Control : max-age = 604800'  服务器说给你index.html和加载里面资源,并告诉你这些资源一周之内不要不必确认了
  
  浏览器刷新的网页再次访问http://localhost:10080/时
  -        里面的资源就不会再发送请求了,直接从缓存中拿  你会在chrome,network中看到Time是0(from memory catch)

  服务器返回数据
  -       服务器只返回index.html文件


  这时候你强制刷新浏览器(command+shift+R) 
  -       '请求报文带 Catche Contrl：no-cache '客户端说我不要缓存过的数据，我要源服务器的数据
  
 服务器返回数据
  -       服务器返回index.html文件和依赖的资源
```
#### 协商缓存
第一种：If-Modified-Since／Last-Modified
服务器会下发一个Last-Modified最后修改时间。然后浏览器会记住这个时间。当浏览器第二次请求时会带上if-modified-since的时间。服务器可以去比较这份文件在if-modified-since的时间后是否修改过。如果没有修改过，那就返回304.

* Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
* If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If- -Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified- Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说 明资源又被改动过，则响应整片资源内容(写在响应消息包体内)，HTTP 200;若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包 体，节省浏览)，告知浏览器继续使用所保存的cache。

上面那个代码中我们服务器并没有实现去记录文件修改时间，我们只要拿一段时间内去比较。我们知道了使用
if-modified-since，服务器就要每次记录文件的一个修改时间。所以用时间去判断并不是很好。
第二种：Etag/ If-None-Match
服务器Etag会下发一个字符串，然后浏览器在第二次请求时会在if-none-match中带上这个字符串。这时候服务器可以比较两个字符串，如果相同，就让浏览器去缓存中去取。

* Etag:web服务器响应请求时，告诉浏览器当前资源在服务器
的唯一标识(生成规则由服务器决定)
* If-None-Match:当资源过期时(使用Cache-Control标识的max- age)，发现资源具有Etage声明，则再次向web服务器请求时带 上头If-None-Match (Etag的值)。web服务器收到请求后发现 有头If-None-Match 则与被请求资源的相应校验串进行比对，决 定返回200或304

## UDP协议
### 面向报文
UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作

* 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
* 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作、

### 不可靠性
1. 无连接
2. 协议收到什么数据就传递什么数据，不会备份数据
3. 没有佣塞控制，以恒定的速度发送数据

### 高效
udp头部8个字节，tcp20个字节

### 传输方式

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

## TCP协议

<img src='https://raw.githubusercontent.com/externalFa/About-interview/master/img/屏幕快照%202018-07-28%20上午10.51.55.png'>
为什么连接建立需要三次握手，而不是两次握手？

防止失效的连接请求报文段被服务端接收，从而产生错误。

PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。
若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。

## 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)
1. 在浏览器地址栏输入URL
2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
 * 如果资源未缓存，发起新请求
 * 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
 * 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control
3. 浏览器解析URL获取协议，主机，端口，path
4. 浏览器组装一个HTTP（GET）请求报文
5. 浏览器获取主机ip地址，过程如下：
 * 浏览器缓存
 * 本机缓存
 * hosts文件
 * 路由器缓存
 * ISP DNS缓存
 * DNS递归查询（可能存在负载均衡导致每次IP不一样）
6. 打开一个socket与目标IP地址，端口建立TCP链接，三次握手
7. TCP链接建立后发送HTTP请求
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将响应报文通过TCP连接发送回浏览器
12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，进行缓存
15. 对响应进行解码（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释
18. 构建DOM树：
 * Tokenizing：根据HTML规范将字符流解析为标记
 * Lexing：词法分析将标记转换为对象并定义属性和规则
 * DOM construction：根据HTML标记关系将对象组成DOM树
19. 解析过程中遇到图片、样式表、js文件，启动下载
20. 构建CSSOM树：
 * Tokenizing：字符流转换为标记流
 * Node：根据标记创建节点
 * CSSOM：节点创建CSSOM树
21. 根据DOM树和CSSOM树构建渲染树:
 * 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none
 * 对每一个可见节点，找到恰当的CSSOM规则并应用
 * 发布可视节点的内容和计算样式
22. js解析如下：
 * 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading
 * HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容
 * 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可 以访问自己script和之前的文档元素
 * 当文档完成解析，document.readState变成interactive
 * 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()
 * 浏览器在Document对象上触发DOMContentLoaded事件
 * 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件
23. 显示页面（HTML解析过程中会逐步显示页面）

## HTTP压缩协议
HTTP压缩协议理解起来很简单，就好像你要给你朋友在QQ上传1个1G文件，需要10分钟，哇网速好快哦。
但是你要是压缩一下，这个文件就变成了300M。再给你朋友传可能就需要3分钟。然后你压缩需要1分钟，他解压需要一分钟。这样你们5分钟就搞定啦。同样的道理。

* http请求头带：Accept-Encoding: gzip, deflate, br

这是浏览器告诉服务器我支持什么样的压缩格式，优先级是什么样的。

* http响应头带：Content-Encoding: gzip

这是服务器告诉浏览器我已经按什么样子的格式压缩了，解压工作你拜托你了
所以在浏览器上我们就需要根据请求头中的Accept-Encoding去判断，浏览器支持什么压缩啊。然后压缩之后再告诉浏览器，我已经给你压缩成什么样子啦。

## 关于跨域和http请求
在另一篇markdown中讲到

## HTTPS
HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。

### HTTPS的优缺点
优点
1 : 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器

2 : HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性

3 : HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

4 : 相比之下，SEO更加友好

缺点

1 : HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电

2 : HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响

3 : SSL证书钱，而且证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗
### HTTP工作原理
```
1.客户使用https url访问服务器，则要求web 服务器建立ssl链接。
2.web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。
3.客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。
4.客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。
5.web服务器通过自己的私钥解密出会话密钥。
6.web服务器通过会话密钥加密与客户端之间的通信。
```
### TLS
TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。

在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

对称加密：

对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。

非对称加密：

有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

1. 客户端发送一个随机值，需要的协议和加密方式
2. 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
4. 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密
通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。

PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。
<img src='https://raw.githubusercontent.com/externalFa/About-interview/master/img/httpor.png'>
## DNS

DNS 的作用就是通过域名查询到具体的 IP。

因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 www.google.com 时，会进行一下操作：

1. 操作系统会首先在本地缓存中查询
2. 没有的话会去系统配置的 DNS 服务器中查询
3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
4. 然后去该服务器查询 google 这个二级域名
5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。

PS：DNS 是基于 UDP 做的查询。

## GET和post的区别
* GET是请求数据，使用URL或Cookie传参。POST是传输实体主体所以会把参数放到报文体中
* GET数据放到URL中，浏览器对URL大小有限制，所以数据大小进行限制。POST是传输实体主体，所以大小没有限制
* GET数据放到URL中，所以安全性肯定不高啊，所以不能用来传递敏感信息。POST相对安全
* GET是请求数据所以URL地址可以后退，而POST发送数据不会（chrome中post就会后退）。
* GET是请求所以会被浏览器主动cache，而POST是发送数据，所以不会除非手动设置。
（
* GET：获取资源
* POST:传输实体主体
* PUT:传输文件
* HEAD:获取报文首部
* DELETE：删除文件
* OPTIONS：查询支持方法
* TRACK：追踪路径
* CONNECT：要求用隧道协议连接代理）

## HTTP和HTTPS的区别

* Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
* 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
* 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
* 开销：Https通信需要证书，而证书一般需要向认证机构购买；  
* Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

#### 三次握手
三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：

* 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
* 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
* 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了
<img src='http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png'>

#### 四次挥手
四次挥手(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：

* 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
* 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
* 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
* 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

<img src='http://static.zybuluo.com/Rico123/ardiuu1otopo9f1jd4df18iz/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png'>

## TCP和UPD的区别
TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：

* TCP是面向连接的，UDP是无连接的；
* TCP是可靠的，UDP是不可靠的；
* TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
* TCP是面向字节流的，UDP是面向报文的；
* TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
* TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大

## TCP如何保证可靠性

TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

　　对于可靠性，TCP通过以下方式进行保证：

* 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
* 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
* 丢弃重复数据：对于重复数据，能够丢弃重复数据；
* 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
* 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
* 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。


## 攻击类型

### DDos攻击
* 客户端向服务端发送请求链接数据包
* 服务端向客户端发送确认数据包
* 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认


DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )：

* 限制同时打开SYN半链接的数目
* 缩短SYN半链接的Time out 时间
* 关闭不必要的服务

### SQL注入
SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

SQL注入攻击的总体思路

* 寻找到SQL注入的位置 
* 判断服务器类型和后台数据库类型 
* 针对不通的服务器和数据库特点进行SQL注入攻击

应对方法：

* 参数绑定：使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和 $ 来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。
* 使用正则表达式过滤传入的参数

### XXS攻击
XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。

XSS 分为三种:

* 反射型XSS : 这种xss，跨站代码一般存在于某一个链接中，当被攻击者访问这样的连接时，跨站代码就被执行，这类跨站代码一般不会存储在服务器上面
* 存储型XSS : 这种xss用起来比较方便，跨站代码会存储在服务器上面数据库中，换句话就是可以持久的进行攻击，亦称持久型XSS
* 基于DOM的XSS : 这是由于客户端脚本自身的解析不正确导致的安全问题



应对方法：

* 漏洞产生的根本原因是 太相信用户提交的数据，对用户所提交的数据过滤不足所导致的，因此解决方案也应该从这个方面入手，具体方案包括：
* 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能 
获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；
* 表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。
* 对数据进行Html Encode 处理
* 过滤或移除特殊的Html标签，例如: `<script>, <iframe> , < for <, > for>, &quot for`
* 过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus” 等等。

　　需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！

### CSRF跨站请求伪造
攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等

如何防御

```
1 、 验证 HTTP Referer 字段；Referer 来判断该请求是否为第三方网站发起的

2 、 在请求地址中添加 token 并验证；由服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。

3 、 在 HTTP 头中自定义属性并验证。可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击
```

## IP地址分类

IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。

　　每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：

* A类地址：以0开头，第一个字节范围：0~127；
* B类地址：以10开头，第一个字节范围：128~191；
* C类地址：以110开头，第一个字节范围：192~223；
* D类地址：以1110开头，第一个字节范围为224~239；
* E类地址：以1111开头，保留地址

### A类地址
A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”

一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。

A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台　

### B类地址
B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”

一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。

B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。　

C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”

一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。

C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。

4). D类地址:多播地址，用于1对多通信，最高位必须是“1110”

D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。

5). E类地址:为保留地址，最高位必须是“1111”

## OSI网络体系结构与TCP/IP协议模型

<img src='http://static.zybuluo.com/Rico123/0qwq331jj8bzgmqst282f6lp/OSI%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8ETCPIP%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png'>

```
OSI七层模型
OSI中的层                         功能                            TCP/IP协议族 
应用层                 文件传输，电子邮件，文件服务，虚拟终 端         TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 
表示层                 数据格式化，代码转换，数据加密                                    没有协议 
会话层                 解除或建立与别的接点的联系                                          没有协议 
传输层                 提供端对端的接口                                                        TCP，UDP 
网络层                 为数据包选择路由                                                        IP，ICMP，RIP，OSPF，BGP，IGMP 
数据链路层           传输有地址的帧以及错误检测功能                            SLIP，CSLIP，PPP，ARP，RARP，MTU
物理层                 以二进制数据形式在物理媒体上传输数据                             ISO2110，IEEE802，IEEE802.2
```

```
TCP/IP中，每一层对应的协议
网络层：IP协议、ICMP协议、ARP协议、RARP协议。
传输层：UDP协议、TCP协议。
应用层：FTP（文件传送协议）、Telenet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议。
```

```
TCP/IP五层模型的协议

应用层 
传输层：四层交换机、也有工作在四层的路由器

网络层：路由器、三层交换机

数据链路层：网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）

物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层
```
在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。 
#### OSI七层模型详解及各层的硬件设备

```
应用层，很简单，就是应用程序。这一层负责确定通信对象，并确保由足够的资源用于通信，这些当然都是想要通信的应用程序干的事情。为操作系统或网络应用程序提供访问网络服务的接口。
应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。

表示层，负责数据的编码、转化，确保应用层的正常工作。这一层，是将我们看到的界面与二进制间互相转化的地方，就是我们的语言与机器语言间的转化。
数据的压缩、解压，加密、解密都发生在这一层。这一层根据不同的应用目的将数据处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。

会话层，负责建立、维护、控制会话，区分不同的会话，以及提供单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务。
我们平时所知的NFS，RPC,X Windows等都工作在这一层。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。

传输层，负责分割、组合数据，实现端到端的逻辑连接。数据在上三层是整体的，到了这一层开始被分割，这一层分割后的数据被称为段(Segment)
。三次握手(Three-way handshake)，面向连接(Connection-Oriented)或非面向连接(Connectionless-Oriented)的服务，流控(Flow control)等都发生在这一层。是第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。
此外，传输层还要处理端到端的差错控制和流量控制问题。
在这一层，数据的单位称为数据段（segment）。
传输层协议的代表包括：TCP、UDP、SPX等

网络层，负责管理网络地址，定位设备，决定路由。我们所熟知的IP地址和路由器就是工作在这一层。
上层的数据段在这一层被分割，封装后叫做包(Packet)，包有两种，一种叫做用户数据包(Data packets)，是上层传下来的用户数据；
另一种叫路由更新包(Route update packets)，是直接由路由器发出来的，用来和其他路由器进行路由信息的交换。
负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互连等功能。
在这一层，数据的单位称为数据包（packet）。
网络层协议的代表包括：IP、IPX、RIP、OSPF等

数据链路层，负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等。我们所熟知的MAC地址和交换机都工作在这一层。
上层传下来的包在这一层被分割封装后叫做帧(Frame)。在不可靠的物理介质上提供可靠的传输。
该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
在这一层，数据的单位称为帧（frame）。
数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等

物理层，就是实实在在的物理链路，负责将数据以比特流的方式发送、接收，就不多说了。

 

各层的设备：

物理层：中继器（Repeater，也叫放大器），集线器，网线。

数据链路层：网桥，交换机。

网络层：路由器。

网关：网络层以上的设备。
```
### TCP UDP对应的协议

```
TCP对应的协议：

（1） FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。

（2） Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。

（3） SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。

（4） POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。

（5）HTTP协议：是从Web服务器传输超文本到本地浏览器的传送协议。

UDP对应的协议：

（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。

（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。
```

## ARP工作原理
(1)首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。

（2）当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。

（3）当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。

（4）源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

广播发送ARP请求，单播发送ARP响应。



## 正向代理和反向代理

#### 正向代理

     正向代理（forward proxy）  ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。

       简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。  

#### 反向代理

    反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。

       理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 

#### 区别

* 位置不同 

 正向代理，架设在客户机和目标主机之间； 
 反向代理，架设在服务器端；

* 代理对象不同 

 正向代理，代理客户端，服务端不知道实际发起请求的客户端； 
 反向代理，代理服务端，客户端不知道实际提供服务的服务端； 



## post数据类型

```
1  application/x-www-form-urlencoded
这应该是最常见的 POST 提交数据的方式了。浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。

2 multipart/form-data; boundary=xxxxxxx
这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <form> 表单的 enctyped 等于 multipart/form-data。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。

3 application/json

application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。

4 text/xml

```

